package scaffold

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
)

// Options controls chart scaffolding behavior.
type Options struct {
	Path    string
	Name    string
	Version string
	Force   bool
}

// CreateChart scaffolds a ComposePack chart directory with starter files.
func CreateChart(opts Options) error {
	if opts.Path == "" {
		return errors.New("path is required")
	}
	if opts.Name == "" {
		return errors.New("chart name is required")
	}
	if opts.Version == "" {
		opts.Version = "0.1.0"
	}

	path := opts.Path
	if err := ensureDirReady(path, opts.Force); err != nil {
		return err
	}

	dirs := []string{
		filepath.Join(path, "templates", "compose"),
		filepath.Join(path, "templates", "files"),
		filepath.Join(path, "templates", "helpers"),
		filepath.Join(path, "files"),
		filepath.Join(path, "files", "config"),
		filepath.Join(path, "templates", "files", "config"),
	}
	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return fmt.Errorf("create directory %s: %w", dir, err)
		}
	}

	files := map[string]string{
		filepath.Join(path, "Chart.yaml"):                                      chartYAML(opts.Name, opts.Version),
		filepath.Join(path, "values.yaml"):                                     defaultValues,
		filepath.Join(path, "templates", "compose", "00-app.tpl.yaml"):         composeTemplate,
		filepath.Join(path, "templates", "files", "config", "message.txt.tpl"): fileTemplate,
		filepath.Join(path, "templates", "helpers", "_helpers.tpl"):            helperTemplate,
		filepath.Join(path, "README.md"):                                       scaffoldReadme(opts.Name),
	}

	for file, content := range files {
		if err := os.WriteFile(file, []byte(content), 0o644); err != nil {
			return fmt.Errorf("write %s: %w", file, err)
		}
	}

	return nil
}

func ensureDirReady(path string, force bool) error {
	info, err := os.Stat(path)
	if os.IsNotExist(err) {
		return os.MkdirAll(path, 0o755)
	}
	if err != nil {
		return err
	}
	if !info.IsDir() {
		return fmt.Errorf("%s exists and is not a directory", path)
	}
	entries, err := os.ReadDir(path)
	if err != nil {
		return err
	}
	if len(entries) > 0 && !force {
		return fmt.Errorf("directory %s is not empty (use --force to overwrite)", path)
	}
	return nil
}

func chartYAML(name, version string) string {
	return fmt.Sprintf(`name: %s
version: %s
description: Starter ComposePack chart
`, name, version)
}

const defaultValues = `app:
  image: busybox
  tag: latest
  command: ["sh", "-c", "mkdir -p /www && cp /usr/share/app-config/message.txt /www/index.html && httpd -f -p 8080 -h /www"]
  env:
    WELCOME_TEXT: "Hello from ComposePack"

sidecar:
  image: busybox
  tag: latest
  command: ["sh", "-c", "while true; do echo 'sidecar alive'; sleep 30; done"]
`

const composeTemplate = `services:
  {{ include "example.fullname" . }}-app:
    image: "{{ .Values.app.image }}:{{ .Values.app.tag }}"
    command: {{ toJson .Values.app.command }}
    volumes:
      - ./files/config/message.txt:/usr/share/app-config/message.txt:ro
    ports:
      - "8080:8080"

  {{ include "example.fullname" . }}-sidecar:
    image: "{{ .Values.sidecar.image }}:{{ .Values.sidecar.tag }}"
    command: {{ toJson .Values.sidecar.command }}
    depends_on:
      - {{ include "example.fullname" . }}-app
`

const fileTemplate = `{{ .Values.app.env.WELCOME_TEXT | default "Hello ComposePack" }}
`

const helperTemplate = `{{- define "example.fullname" -}}
{{ printf "%s" .Release.Name }}
{{- end -}}
`

func scaffoldReadme(name string) string {
	return fmt.Sprintf(`# %s

This directory was generated by composepack init. Key files:

- Chart.yaml: chart metadata (name, version, description).
- values.yaml: default values merged with user overrides (additional -f files and --set flags).
- templates/compose/*.tpl.yaml: templated Compose fragments rendered into the final docker-compose.yaml.
- templates/files/**/*.tpl: templated runtime files copied under .cpack-releases/<release>/files.
- templates/helpers/_helpers.tpl: reusable snippets for {{ include }}.

Edit the templates/values to match your app, then run:

composepack install ./%s --name dev --auto-start

`, name, filepath.Base(name))
}
